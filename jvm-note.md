## Java内存笔记
>>  from java架构沉思录 -- 一文理清Java内存区域
原文
[c-java内存模型](https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247485026&idx=1&sn=982cd439af2e9850dfe2770e2673fe40&chksm=9bf4b6d7ac833fc1ad4163a00e12072ccb7884b8cfb046d8c1a6965b985752c5b1c2c57774a3&mpshare=1&scene=1&srcid=0912zudJNxS2x1be4OFl58Nv#rd)



根据《java虚拟机规范》将Java虚拟机所管理的内存分为以下几个运行时数据区域：
 * 线程私有内存
   * 程序计数器
   * Java虚拟机栈区
   * 本地方法区
 * 线程公用内存
   * Java堆区
   * 方法区
   
### 1. 程序计数器
  在JVM中，程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选择下一跳
需要执行的字节码指令。  每个线程为了切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各个线程互不影响，独立存储，这是“线程私有的”；

### 2. Java虚拟机栈
Java虚拟机栈也是线程私有的，他的生命周期和线程相同，描述的是Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，
动态链接，方法出口等信息；  另外，除了栈帧的出栈和入栈，Java虚拟机栈不会受其他因素的影响，所以栈帧可以在系统的堆中分配；（JVM保留2个内存区，Java堆和本机
‘或系统堆’，Java堆存储对象的实例，系统堆用于底层实施特定的Java对象）

当线程请求的栈深度大于虚拟机所允许的深度，讲抛出StackOverflowErroe异常；虚拟机的栈大多数都是可以动态拓展的，如果拓展是无法申请足够内存，抛出OutOfMemoryError;

`JVM专家R大`

### 3. 本地方法栈
本地方法栈Native Method Stack与虚拟机栈所发生的作用类似，区别在于，虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈为虚拟机 使用到的是Native方法，或
服务，所谓的本地方法，NativeMethod: 是指一个Java调用非Java代码的接口，它是由非Java语言实现，如C语言；

### 4. Java堆
对于大多数应用，Java堆（heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的是存放Java对象实例，
几乎所有的对象实例都在这里分配内存。 由于Java堆区是垃圾收集器管理的主要区域，也成为`GC堆`； 
当前主流的虚拟机都按照可拓展来实现（通过-Xmx 和 -Xms控制）。 如果堆上没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemeryError异常。

Java中堆和栈的区别，1. 功能不同，栈内存用来存储局部变量，操作数栈等信息，堆内存用来存储Java中的对象。2.共享性不同，栈内存是线程私有的，堆内存是所有线程共享的。
3. 空间区别，栈内存远远小于堆内存； 4. 异常错误不同，`栈`有两种异常情况，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常，
如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。`堆`一般在堆中没有内存完成实例分配，并且堆也无法进行扩展时，抛出 OutOfMemoryError 异常。

### 5. 方法区
Method Area 方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的`类信息，常量,静态变量，即时编译器编译后的代码等数据`。 Java虚拟机规范把方法区
描述为堆的一个逻辑部分，但是它有一个别名“非堆”。

对于HotSpot虚拟机来讲，方法区域又被称为 "永久代"，本质上两者并不等价，仅仅是因为`HotSpot虚拟机`的设计团队选择把 GC 分代收集扩展至方法区，
或者说使用 永久代来实现方法区而已，这样的HotSpot的垃圾收集器可以像 管理 Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作；

由于 永久代内可能发生内存泄漏或溢出的问题(永久代有 -XX:MaxPermSize的上限)而导致的 java.lang.OutOfMemoryError: PermGen space
`jdk小组从jdk1.7开始就筹划移除永久代，并且在JDK1.7中把字符串常量，符号引用等移除了永久代，到了Java8，永久代被彻底移除了JVM，取而代之的是元空间（Metaspace）`
JDK 8开始将类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace;
R大是国内JVM巨牛级人物，他的回答都是非常权威的，所以学习 JVM的知识可以多参考 R大的分析
《深入理解Java虚拟机》
