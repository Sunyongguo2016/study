## Java内存笔记
>>  from java架构沉思录 -- 一文理清Java内存区域
原文
[c-java内存模型](https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247485026&idx=1&sn=982cd439af2e9850dfe2770e2673fe40&chksm=9bf4b6d7ac833fc1ad4163a00e12072ccb7884b8cfb046d8c1a6965b985752c5b1c2c57774a3&mpshare=1&scene=1&srcid=0912zudJNxS2x1be4OFl58Nv#rd)



根据《java虚拟机规范》将Java虚拟机所管理的内存分为以下几个运行时数据区域：
 * 线程私有内存
   * 程序计数器
   * Java虚拟机栈区
   * 本地方法栈
 * 线程公用内存
   * Java堆区
   * 方法区
   
### 1. 程序计数器
  在JVM中，程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选择下一跳
需要执行的字节码指令。  每个线程为了切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各个线程互不影响，独立存储，这是“线程私有的”；

### 2. Java虚拟机栈
Java虚拟机栈也是线程私有的，他的生命周期和线程相同，描述的是Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，
动态链接，方法出口等信息；  另外，除了栈帧的出栈和入栈，Java虚拟机栈不会受其他因素的影响，所以栈帧可以在系统的堆中分配；（JVM保留2个内存区，Java堆和本机
‘或系统堆’，Java堆存储对象的实例，系统堆用于底层实施特定的Java对象）

当线程请求的栈深度大于虚拟机所允许的深度，讲抛出StackOverflowErroe异常；虚拟机的栈大多数都是可以动态拓展的，如果拓展是无法申请足够内存，抛出OutOfMemoryError;

`JVM专家R大`

### 3. 本地方法栈
本地方法栈Native Method Stack与虚拟机栈所发生的作用类似，区别在于，虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈为虚拟机 使用到的是Native方法，或
服务，所谓的本地方法，NativeMethod: 是指一个Java调用非Java代码的接口，它是由非Java语言实现，如C语言；

### 4. Java堆
对于大多数应用，Java堆（heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的是存放Java对象实例，
几乎所有的对象实例都在这里分配内存。 由于Java堆区是垃圾收集器管理的主要区域，也成为`GC堆`； 
当前主流的虚拟机都按照可拓展来实现（通过-Xmx 和 -Xms控制）。 如果堆上没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemeryError异常。

Java中堆和栈的区别，1. 功能不同，栈内存用来存储局部变量，操作数栈等信息，堆内存用来存储Java中的对象。2.共享性不同，栈内存是线程私有的，堆内存是所有线程共享的。
3. 空间区别，栈内存远远小于堆内存； 4. 异常错误不同，`栈`有两种异常情况，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常，
如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。`堆`一般在堆中没有内存完成实例分配，并且堆也无法进行扩展时，抛出 OutOfMemoryError 异常。

### 5. 方法区
Method Area 方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的`类信息，常量,静态变量，即时编译器编译后的代码等数据`。 Java虚拟机规范把方法区
描述为堆的一个逻辑部分，但是它有一个别名“非堆”。

对于HotSpot虚拟机来讲，方法区域又被称为 "永久代"，本质上两者并不等价，仅仅是因为`HotSpot虚拟机`的设计团队选择把 GC 分代收集扩展至方法区，
或者说使用 永久代来实现方法区而已，这样的HotSpot的垃圾收集器可以像 管理 Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作；

由于 永久代内可能发生内存泄漏或溢出的问题(永久代有 -XX:MaxPermSize的上限)而导致的 java.lang.OutOfMemoryError: PermGen space
`jdk小组从jdk1.7开始就筹划移除永久代，并且在JDK1.7中把字符串常量，符号引用等移除了永久代，到了Java8，永久代被彻底移除了JVM，取而代之的是元空间（Metaspace）`
JDK 8开始将类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace;
R大是国内JVM巨牛级人物，他的回答都是非常权威的，所以学习 JVM的知识可以多参考 R大的分析
《深入理解Java虚拟机》



###  1-1. 类加载，对象创建到内存
1.  java对象 日志打印出来是对象的@ac2531这样的数据， 可以使用logback MessageConverter，一次处理，到处使用，不用每个地方json.toString();

2.  java 内存分配的时候，如何保证线程安全呢？一种是对内存加锁，CAS； 另外是每个线程拥有一块用于分配对象空间的内存，这种方法是TLAB(Thread Local Allocation Buffer 即线程本地分配缓存);  
加锁不方便，消耗太大，TLAB 方式， 只是给了线程分配内存的权限，限定了某个内存块，对于读写，垃圾回收，其他线程还是可以用的； 另外给线程分配 一块可以分配空间的内存，本身就是需要保证原子性的，但是这个开销相对来说很小。

3. 对象大多数分配在堆里， 另外还有在栈内存上和TLAB， 栈内存可以理解，就是函数方法里的对象，（也就是在一定作用域范围里的.逃逸分析） 在线程私有的栈内存，执行后销毁，不增加GC的工作量。
TLAB(Thread Local Allocation Buffer 即线程本地分配缓存)； 即构造一种线程私有的堆空间，这块堆空间很小，但是只要有，就可以每个线程在分配对象到堆空间时，先分配到自己所属的那一块堆空间中，避免同步带来的效率问题，从而提高分配效率；
TLAB（加速堆上对象的分配），因为是线程自己拥有分配对象内存的堆空间，没有多线程争资源，所以分配对象快。

4. java对象分配过程：对象分配优先级流程图

--------------根据前几天的类加载机制， 和现在的对象分配内存过程，能完整解释清java对象创建过程--------------------------

### 2-1. 编译，前端编译，后端编译成机器指令
1. java，经过前端编译，生成字节码class, 其中是字节码指令,前端编译包括如词法分析，语法分析，语义分析，中间代码生成（语法糖，自动拆包）等。
后端编译，.class 文件生成为机器指令过程； 过程包括如解释器， 编译器，对字节码处理为机器指令。

2.1.字节码，在jvm 支持下，可以运行时解释为机器语言（机器语言是01），或者如果频繁使用会编译为机器语言存在缓存里，下次方便使用，（编译器会根据算法把频繁使用的代码编译出来缓存）。

2.2. 字节码可以类比为上帝的旨意， 然后jvm执行字节码的指令集，可能运行函数时，开辟局部变量表空间，开辟操作数栈。读取指令，根据变量入栈，出栈，算出结果；
也可以理解为数据作为原料菜，然后指令作为食谱，cpu是大厨，执行指令，把结果存入一个内存位置，然后被取出。

3. cpu执行，看过一篇博客，简单的说就是二极管，只有一端可以输入通过，另一端不可输入通过， 然后基于这个基础可以画出电路图，做出异或门，与非门，加法运算，复杂的运算等。

--------------根据hollis博客，和之前学过的汇编知识，以及cpu相关内容，能理解java，编译后字节码，然后jvm再编译为机器码，cpu执行的过程--------------------------


### java 内存面试详解1

* JVM管理的内存结构是怎样的？
* 不同的虚拟机在实现运行时内存的时候有什么区别？
* 运行时数据区中哪些区域是线程共享的？哪些是独享的？
* 除了JVM运行时内存以外，还有什么区域可以用吗？
* 堆和栈的区别是什么？
* Java中的数组是存储在堆上还是栈上的？
* Java中的对象创建有多少种方式？
* Java中对象创建的过程是怎么样的？
* Java中的对象一定在堆上分配内存吗？
* 如何获取堆和栈的dump文件？

[java内存面试-1](https://www.hollischuang.com/archives/3875）
