## 一、Java内存笔记
>>  from java架构沉思录 -- 一文理清Java内存区域
原文
[c-java内存模型](https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247485026&idx=1&sn=982cd439af2e9850dfe2770e2673fe40&chksm=9bf4b6d7ac833fc1ad4163a00e12072ccb7884b8cfb046d8c1a6965b985752c5b1c2c57774a3&mpshare=1&scene=1&srcid=0912zudJNxS2x1be4OFl58Nv#rd)



根据《java虚拟机规范》将Java虚拟机所管理的内存分为以下几个运行时数据区域：
 * 线程私有内存
   * 程序计数器
   * Java虚拟机栈区
   * 本地方法栈
 * 线程公用内存
   * Java堆区
   * 方法区
   
### 1. 程序计数器
  在JVM中，程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选择下一跳
需要执行的字节码指令。  每个线程为了切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各个线程互不影响，独立存储，这是“线程私有的”；

### 2. Java虚拟机栈
Java虚拟机栈也是线程私有的，他的生命周期和线程相同，描述的是Java方法执行的内存模型，每个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，
动态链接，方法出口等信息；  另外，除了栈帧的出栈和入栈，Java虚拟机栈不会受其他因素的影响，所以栈帧可以在系统的堆中分配；（JVM保留2个内存区，Java堆和本机
‘或系统堆’，Java堆存储对象的实例，系统堆用于底层实施特定的Java对象）

当线程请求的栈深度大于虚拟机所允许的深度，讲抛出StackOverflowErroe异常；虚拟机的栈大多数都是可以动态拓展的，如果拓展是无法申请足够内存，抛出OutOfMemoryError;

`JVM专家R大`

### 3. 本地方法栈
本地方法栈Native Method Stack与虚拟机栈所发生的作用类似，区别在于，虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈为虚拟机 使用到的是Native方法，或
服务，所谓的本地方法，NativeMethod: 是指一个Java调用非Java代码的接口，它是由非Java语言实现，如C语言；

### 4. Java堆
对于大多数应用，Java堆（heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的是存放Java对象实例，
几乎所有的对象实例都在这里分配内存。 由于Java堆区是垃圾收集器管理的主要区域，也成为`GC堆`； 
当前主流的虚拟机都按照可拓展来实现（通过-Xmx 和 -Xms控制）。 如果堆上没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemeryError异常。

Java中堆和栈的区别，1. 功能不同，栈内存用来存储局部变量，操作数栈等信息，堆内存用来存储Java中的对象。2.共享性不同，栈内存是线程私有的，堆内存是所有线程共享的。
3. 空间区别，栈内存远远小于堆内存； 4. 异常错误不同，`栈`有两种异常情况，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常，
如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。`堆`一般在堆中没有内存完成实例分配，并且堆也无法进行扩展时，抛出 OutOfMemoryError 异常。

### 5. 方法区
Method Area 方法区和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的`类信息，常量,静态变量，即时编译器编译后的代码等数据`。 Java虚拟机规范把方法区
描述为堆的一个逻辑部分，但是它有一个别名“非堆”。

对于HotSpot虚拟机来讲，方法区域又被称为 "永久代"，本质上两者并不等价，仅仅是因为`HotSpot虚拟机`的设计团队选择把 GC 分代收集扩展至方法区，
或者说使用 永久代来实现方法区而已，这样的HotSpot的垃圾收集器可以像 管理 Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作；

由于 永久代内可能发生内存泄漏或溢出的问题(永久代有 -XX:MaxPermSize的上限)而导致的 java.lang.OutOfMemoryError: PermGen space
`jdk小组从jdk1.7开始就筹划移除永久代，并且在JDK1.7中把字符串常量，符号引用等移除了永久代，到了Java8，永久代被彻底移除了JVM，取而代之的是元空间（Metaspace）`
JDK 8开始将类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace;
R大是国内JVM巨牛级人物，他的回答都是非常权威的，所以学习 JVM的知识可以多参考 R大的分析
《深入理解Java虚拟机》



###  1-1. 类加载，对象创建到内存
1.  java对象 日志打印出来是对象的@ac2531这样的数据， 可以使用logback MessageConverter，一次处理，到处使用，不用每个地方json.toString();

2.  java 内存分配的时候，如何保证线程安全呢？一种是对内存加锁，CAS； 另外是每个线程拥有一块用于分配对象空间的内存，这种方法是TLAB(Thread Local Allocation Buffer 即线程本地分配缓存);  
加锁不方便，消耗太大，TLAB 方式， 只是给了线程分配内存的权限，限定了某个内存块，对于读写，垃圾回收，其他线程还是可以用的； 另外给线程分配 一块可以分配空间的内存，本身就是需要保证原子性的，但是这个开销相对来说很小。

3. 对象大多数分配在堆里， 另外还有在栈内存上和TLAB， 栈内存可以理解，就是函数方法里的对象，（也就是在一定作用域范围里的.逃逸分析） 在线程私有的栈内存，执行后销毁，不增加GC的工作量。
TLAB(Thread Local Allocation Buffer 即线程本地分配缓存)； 即构造一种线程私有的堆空间，这块堆空间很小，但是只要有，就可以每个线程在分配对象到堆空间时，先分配到自己所属的那一块堆空间中，避免同步带来的效率问题，从而提高分配效率；
TLAB（加速堆上对象的分配），因为是线程自己拥有分配对象内存的堆空间，没有多线程争资源，所以分配对象快。

4. java对象分配过程：对象分配优先级流程图

--------------根据前几天的类加载机制， 和现在的对象分配内存过程，能完整解释清java对象创建过程--------------------------

### 2-1. 编译，前端编译，后端编译成机器指令
1. java，经过前端编译，生成字节码class, 其中是字节码指令,前端编译包括如词法分析，语法分析，语义分析，中间代码生成（语法糖，自动拆包）等。
后端编译，.class 文件生成为机器指令过程； 过程包括如解释器， 编译器，对字节码处理为机器指令。

2.1.字节码，在jvm 支持下，可以运行时解释为机器语言（机器语言是01），或者如果频繁使用会编译为机器语言存在缓存里，下次方便使用，（编译器会根据算法把频繁使用的代码编译出来缓存）。

2.2. 字节码可以类比为上帝的旨意， 然后jvm执行字节码的指令集，可能运行函数时，开辟局部变量表空间，开辟操作数栈。读取指令，根据变量入栈，出栈，算出结果；
也可以理解为数据作为原料菜，然后指令作为食谱，cpu是大厨，执行指令，把结果存入一个内存位置，然后被取出。

3. cpu执行，看过一篇博客，简单的说就是二极管，只有一端可以输入通过，另一端不可输入通过， 然后基于这个基础可以画出电路图，做出异或门，与非门，加法运算，复杂的运算等。

--------------根据hollis博客，和之前学过的汇编知识，以及cpu相关内容，能理解java，编译后字节码，然后jvm再编译为机器码，cpu执行的过程--------------------------


### java 内存面试详解1

* JVM管理的内存结构是怎样的？
* 不同的虚拟机在实现运行时内存的时候有什么区别？
* 运行时数据区中哪些区域是线程共享的？哪些是独享的？
* 除了JVM运行时内存以外，还有什么区域可以用吗？
* 堆和栈的区别是什么？
* Java中的数组是存储在堆上还是栈上的？
* Java中的对象创建有多少种方式？
* Java中对象创建的过程是怎么样的？
* Java中的对象一定在堆上分配内存吗？
* 如何获取堆和栈的dump文件？

[hollis--java内存面试-1](https://www.hollischuang.com/archives/3875)


## 二、jvm-java内存结构

java 成神之路--基础篇 -jvm 内存结构

一、java内存组成及堆内存介绍

1. JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给 自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法 的代码都在非堆内存中。

2. java 1.4之后引入了NIO，除了能调用本身的内存外，还可通过native方法调用本地主存。作为JAVA开发者我们经常用java.nio.DirectByteBuffer对象进行堆外内存的管理和使用，它会在对象创建的时候就分配堆外内存，注意使用这个方法必须手动回收内存。

3. ava堆空间分成三个区域，分别叫作New Generation, Old Generation或叫作Tenured Generation，还有Perm Space。 permSpace 主要放java编译后的class文件

4. 使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存；

二、java 堆栈详解（详解栈）

1. java堆栈区别：抛出异常不用 栈：stackOverflowError 堆： OutofMemoryError

2.深入理解栈： 栈帧由三部分组成：局部变量区、操作数栈、帧数据区。每个方法有一个栈帧，视方法所需大小而定。 会记录方法返回出口；

2.1. 局部变量区 是一个数组，以一个字长为单位，包括入参，局部变量等； 操作数栈，可理解为存储计算时，临时数据的存储区域，栈结构，如计算加法时 2个入参先后入栈，然后出栈cpu将计算结果压入栈，最后局部变量表将栈中数据取出放到自己结构中；

2.2 除了局部变量区和操作数栈外，java栈帧还需要一些数据来支持常量池解析、正常方法返回以及异常派发机制。这些数据都保存在java栈帧的帧数据区中。

2.3 每个线程上有自己的栈，栈是由栈帧组成的，栈帧由操作数栈，局部变量表，帧数据区组成。

三、java 内存之方法区和运行时常量池 （转载--漠然-内存之方法区和运行时常量池）

1. 方法区的作用是存储 Java 类的结构信息，当我们创建对象实例后，对象的类型信息存储在方法堆之中，实例数据存放在堆中；类型信息指的是定义在 Java 代码中的常量、静态变量、以及在类中声明的各种方法、方法字段等等；同时可能包括即时编译器编译后产生的代码数据。 该区域无法满足内存需求会抛出outOfMemory异常

2. 运行时常量池是方法区的一部分， 作用是存储 Java 类文件常量池中的符号信息，栈在执行时会根据符号信息找实际的常量位置对应数据，运行时常量池 中保存着一些 class 文件中描述的符号引用，同时还会将这些符号引用所翻译出来的直接引用存储在 运行时常量池 中；运行时常量池中的内容并不全部来自 class 常量池，class 常量池并非运行时常量池的唯一数据输入口；在运行时可以通过代码生成常量并将其放入运行时常量池中； 会抛出outOfMemory异常。

3. jdk1.2-1.6 ,HotSpot 使用永久代实现方法区，便于直接gc的回收机制，应用到方法区；
JDK7中符号表被移动到 Native Heap中，字符串常量和类引用被移动到 Java Heap中；
在 JDK8 中，永久代已完全被元空间(Meatspace)所取代。


## 三、java-内存模型

java 成神之路 -jvm java内存模型

### 一、jVM内存结构 VS Java内存模型 VS Java对象模型  (hollis hollis-from)

#### 1.  jvm内存结构，jvm内存模型，java 对象模型是3个不同的概念

2. java内存结构：Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁；

3. 方法区只是jvm规范中的一种概念，具体实现不同厂家都有自己的方式。

4. 做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能

#### 5.  java内存模型 ：

堆和方法区线程共享，多个线程可能可以操作保存在堆或者方法区中的同一个数据。这也就是我们常说的“Java的线程间通过共享内存进行通信”。

6. Java内存模型是根据英文Java Memory Model（JMM）翻译过来的。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念，JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的

7. 简单总结下，Java的多线程之间是通过共享内存进行通信的，而由于采用共享内存进行通信，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字；在Java中，JMM是一个非常重要的概念，正是由于有了JMM，Java的并发编程才能避免很多问题

#### 8.java对象模型：

Java是一种面向对象的语言，而Java对象在JVM中的存储也是有一定的结构的。而这个关于Java对象自身的存储模型称之为Java对象模型。

9. HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（Ordinary Object Pointer）指的是普通对象指针，而Klass用来描述对象实例的具体类型。
每一个Java类，在被JVM加载的时候，JVM会给这个类创建一个instanceKlass，保存在方法区，用来在JVM层表示该Java类。当我们在Java代码中，使用new创建一个对象的时候，JVM会创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据。





###  二、java内存模型详解（hollis hollis-from） 



1. java 内存模型是比较难懂的一个，在java内存结构，java内存模型，java对象模型里；



2.CPU 与缓存一致性，CPU技术发展很快，而内存则相对很慢，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间；  因此，人们就提出一个解决办法，就是加高速缓存，在内存和cpu之间，增加了3级缓存；



3. 按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的



4. 单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存



5. 随着计算机能力不断提升，仅仅是多级缓存不足以发挥CPU的计算能力，开始支持多线程编程了。  单线程，CPU只有一个线程执行任务，没有数据冲突；   单核CPU，多线程，由于一个时间片只有一个线程执行任务，所以数据不会冲突（假设都是从cache3取数据，每个时间片上线程要完成对cache3上的取，存数据； 所以线程共享一个数据，也不会冲突）；  



6. 多核CPU，多线程。每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。


7. 在CPU和主存之间增加缓存，在多核多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致（每个核同时修改同一份主存取出的cache,然后数据就可能不一致）。



8.处理器优化和指令重排， 这2中操作可能会把指令乱序，重排（因此多线程要考虑原子性，可见性，以及有序性问题）



9. 并发编程，为了保证数据的安全，需要满足以下三个特性：



原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。有序性即程序执行的顺序按照代码的先后顺序执行。

缓存一致性问题其实就是可见性问题。而处理器优化是可以导致原子性问题的。指令重排即会导致有序性问题。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。





#### 10. 什么是内存模型；

为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。  为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范；通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性



#### 11. 什么是Java内存模型；

计算机内存模型是解决多线程场景下并发问题的一个重要规范，不同语言的有自己的实现方式，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。



12.Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。  ！而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。






13. 总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。

#### 14. java内存模型的实现；

在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字 ，封装了底层实现，供开发者使用。




15. 在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit，这2个字节码对应的就是synchronized；



16. Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性



17.在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：

volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。

这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。

但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用





三、内存模型怎么解决缓存一致性问题（hollis hollis-from） 



1. 缓存一致性问题。硬件层面的问题，指的是由于多核计算机中有多套缓存，各个缓存之间的数据不一致性问题。



PS：这里还需要再重复一遍，Java多线程中，每个线程都有自己的工作内存，需要和主存进行交互。这里的工作内存和计算机硬件的缓存并不是一回事儿，只是可以相互类比。所以，并发编程的可见性问题，是因为各个线程之间的本地内存数据不一致导致的，和计算机缓存并无关系。



缓存一致性协议。用来解决缓存一致性问题的，常用的是MESI协议。

内存一致性模型。屏蔽计算机硬件问题，主要来解决并发编程中的原子性、有序性和一致性问题。

实现内存一致性模型的时候可能会用到缓存一致性模型。



2.既然在硬件层面，已经有了缓存一致性协议，可以保证缓存的一致性即并发编程中的可见性，那么为什么在写多线程的代码的时候，程序员要自己使用volatile、synchronized等关键字来保证可见性？ 因为缓存一致性协议是硬件层面的， volatile 是java 内存模型层面讲的； java内存模型是java语言的，内存模型，是计算机层面，针对计算机的；





四、视频 未读



###　五、java内存模型FAQ （http://ifeve.com/jmm-faq/）

1.  java 内存模型FAQ，内存模式是针对多线程提出的，有硬件方面的处理，也有软件方面的映射处理，比如java的final字段，是软件方面的处理，最后要映射的硬件的支持上。 C, C++ 不同于java， 都没有被设计成直接支持多线程，可以理解为不支持内存模型；由于java旧内存模型不合理，然后产生JSR 133，对关键字做了重新的定义， 修复；





2.  没有正确同步的代码对于不同的人来说可能会有不同的理解。在Java内存模型这个语义环境下，我们谈到“没有正确同步”，我们的意思是：

一个线程中有一个对变量的写操作，
另外一个线程对同一个变量有读操作，
而且写操作和读操作没有通过同步来保证顺序。
当这些规则被违反的时候，我们就说在这个变量上有一个“数据竞争”(data race)。一个有数据竞争的程序就是一个没有正确同步的程序。





3. 同步会做什么？ （http://ifeve.com/jmm-faq-synchronization/）

最广为人知的就是互斥 ——一次只有一个线程能够获得一个监视器，因此，在一个监视器上面同步意味着一旦一个线程进入到监视器保护的同步块中，其他的线程都不能进入到同一个监视器保护的块中间，除非第一个线程退出了同步块



但是同步的含义比互斥更广。同步保证了一个线程在同步块之前或者在同步块中的一个内存写入操作以可预知的方式对其他有相同监视器的线程可见。当我们退出了同步块，我们就释放了这个监视器，这个监视器有刷新缓冲区到主内存的效果，因此该线程的写入操作能够为其他线程所见。在我们进入一个同步块之前，我们需要获取监视器，监视器有使本地处理器缓存失效的功能，因此变量会从主存重新加载，于是其它线程对共享变量的修改对当前线程来说就变得可见了。





volatile的语义已经被加强了，已经快达到同步的级别了。为了可见性的原因，每次读取和写入一个volatile字段已经像一个半同步操作了

重点注意：对两个线程来说，为了正确的设置happens-before关系，访问相同的volatile变量是很重要的 ； valatile 变量刷新到主存之前，valatile之前的代码也都执行了，因此和valitile同一级别的数据， 也是被可见的。



为甚么要关注内存模型？



为什么你需要关注java内存模型？并发程序的bug非常难找。它们经常不会在测试中发生，而是直到你的程序运行在高负荷的情况下才发生，非常难于重现和跟踪。你需要花费更多的努力提前保证你的程序是正确同步的。这不容易，但是它比调试一个没有正确同步的程序要容易的多。




###　六、深入理解java内存模型--基础

（from 程晓明  https://www.infoq.cn/article/java-memory-model-1/）

1. 只有共享变量才有线程安全问题，像线程栈区数据没有线程安全问题，不用java内存模型

2. Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化

3.线程之间通信：线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤：
  首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。
  然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。

从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。

4. 对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序，JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证

5. 内存屏障，指令重排序，为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序；简单理解为保证一批指令必须在其他指令之前，如修改某个数据并刷新到主存，必须是先执行的，此处禁止了重排序，并保障某些指令的执行顺序； 确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。


6. happens-before
从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）；JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系；

6.1 happens-before 规则如下：
程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。
传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C

一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。


###　七、深入理解内存模型二--重排序（程晓明 ）

1. 数据依赖性 概念： 3中操作，读写，读读，写读， 不可改变顺序，否则结果有误，这中类型的操作就时有数据依赖性的操作。编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序 ，这里针对单个CPU，单个线程。

2. as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。 为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序

as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题

3.  happens- before 的程序顺序规则；（概念，规范）

4. 多线程，数据依赖不可保证结果正确性

数据依赖，as-if-serial ,happens-before 在单线程可以保证结果正确性，但是在多线程环境下，只要抓住数据依赖的概念，就可以判断，有的场景不能保证结果正确性。

在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果

###　八、 顺序一致性（程晓明）

1. JMM 对正确同步的多线程程序的内存一致性做了如下保证：如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）-- 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同

２．同步程序的顺序一致性效果

顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性：

一个线程中的所有操作必须按照程序的顺序来执行。
（不管程序是否同步）所有线程都只能看到一个统一的单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见
JMM 会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（符合多线程顺序一致性，即线程对于内存的操作，看起来是串行的）


JMM, JAVA内存模型，保证了多线程下的数据结果正确性。具体的细节，（数据依赖，顺序一致性）都是JMM做的，给程序员屏蔽了细节。

3.总线， 内存与CPU之间，可以控制到，一次控制只支持一个CPU的读或写操作，即原子性，还可以并发传递数据。

数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过一系列步骤来完成的，这一系列步骤称之为总线事务（bus transaction）。总线事务包括读事务（read transaction）和写事务（write transaction）
