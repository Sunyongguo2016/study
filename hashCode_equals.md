1. 哈希算法， 不可被逆向； 一个输入有一个输出，不可逆向，一般用途是网站md5加密， 一般还需要加随机值盐再md5;
    比如： password + “用户名”  md5;  避开 彩虹表的攻击（彩虹表， 把常见的字符串 对应的md5值存起来，然后比对）

2. object .hashCode()  返回这个对象的 唯一hash值； hashCode 值在对象初始化， new 出来的时候就存在对象的头（markword）信息中了，
不需要再计算，很快就找到。
hashcode 就是用来查找哈希表的位置。

3. hashMap 取值的过程， 根据对象 ，先 hashCode ,然后再 equals(); 查找到对应的值；
 所以重写了 一个对象的equals, 也要重写其equals方法；

4. 如果需要写 equals 和hashcode  ，可以使用idea , 自动生成， 会比较完善一点；

5. == 和equals ,== 是对对象的地址比较， 是比较对象指向对内存的栈内存中的地址； 
equals 默认源码是 == ，然后自己可以重写 ，一般用来逻辑上相等

```
hashCode()方法给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap。

解释一下这个程序（String的API中写到）：s[0]*31^(n-1) + s[1]*31^(n-2) + … + s[n-1]
      使用 int 算法，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^ 表示求幂（空字符串的哈希码为 0）。
      (31是质数， 容易产生随机的结果，而且是个不大不小的质数，散列分布计算结果)

       想要弄明白hashCode的作用，必须要先知道Java中的集合。　　
       总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。这里就引出一个问题：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？
        这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。   
       于是，Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上，初学者可以简单理解，hashCode方法实际上返回的就是对象存储的物理地址（实际可能并不是）。  
       这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。  

 #简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率！

Java对象的eqauls方法和hashCode方法是这样规定的：

1、相等（相同）的对象必须具有相等的哈希码（或者散列码）。

2、如果两个对象的hashCode相同，它们并不一定相同。
```



Hashset、Hashmap、Hashtable与hashcode()和equals()的密切关系

```
重写equals()和hashcode()小结：

　　1.重点是equals，重写hashCode只是技术要求（为了提高效率）
      2.为什么要重写equals呢？因为在java的集合框架中，是通过equals来判断两个对象是否相等的
      3.在hibernate中，经常使用set集合来保存相关对象，而set集合是不允许重复的。在向HashSet集合中添加元素时，其实只要重写equals()这一条也可以。但当hashset中元素比较多时，或者是重写的equals()方法比较复杂时，我们只用equals()方法进行比较判断，效率也会非常低，所以引入了hashCode()这个方法，只是为了提高效率，且这是非常有必要的。
```

