## 类加载机制 笔记

jvm 类加载机制
重点： 类准备阶段为类分配内存，初始化阶段执行类初始化代码；

前文回顾

JVM在什么情况下会加载一个类？

从实用角度出发，来看看验证、准备、解析和初始化的过程

核心阶段：初始化

类加载器和双亲委派机制

1. 前文回顾
class文件，加载到jvm中，然后jvm解析class文件中的字节码； 加载到jvm的过程，就是类加载机制的过程。

2.JVM在什么情况下会加载一个类？

一个类从加载到使用，一般会经历下面的这个过程：

加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

class文件是什么时候加载到jvm内存中的呢？其实答案非常简单，就是在你的代码中用到这个类的时候（回忆异步保存任务线程池 static{} 方法块，理解类是被用到的时候加载到内存中的）





简单概括一下：首先你的代码中包含“main()”方法的主类一定会在JVM进程启动之后被加载到内存，开始执行你的“main()”方法中的代码

接着遇到你使用了别的类，比如“ReplicaManager”，此时就会从对应的“.class”字节码文件加载对应的类到内存里来。



3.从实用角度出发，来看看验证、准备和初始化的过程



验证：根据Java虚拟机规范，来校验你加载进来的“.class”文件中的内容，是否符合指定的规范

准备：ReplicaManager.class验证后，准备工作，其实就是给这个“ReplicaManager”类分配一定的内存空间，static修饰的变量分配一个内存空间，并给一个默认初始值，如int修饰的值 默认为0。

解析：这个阶段，实际上是把符号引用替换为直接引用的过程（非重点）

4.初始化：核心阶段，会正式执行我们的类初始化的代码（如类变量赋值，static修饰代码块），比如static 变量 flushInte = 5; 这个阶段赋值为5；



初始化类的时候，如果父类没有初始化，会先验证，准备和初始化父类



5.类加载器和双亲委派机制

类加载过程，是依靠类加载器完成的。



启动类加载器 （Bootstrap ClassLoader）

-->

扩展类加载器（Extension ClassLoader）

-->



应用程序类加载器（Application ClassLoader）

-->

自定义类加载器



基于如上亲自结构，有一个双亲委派模式加载机制；



就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载

但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器,可以避免多层级的加载器结构重复加载某些类。

双亲委派加载机制，是在class 加载到jvm内存之后，再找那个classloader去加载的。



